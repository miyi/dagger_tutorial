<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      [dg-cloak] {
        display: none !important;
      }
    </style>
    <!-- cloak style -->
    <link rel="stylesheet" href="./styles/styles.css" />
    <link rel="stylesheet" href="highlightjs/github-dark.min.css" />
    <link
      href="http://fonts.googleapis.com/css?family=Roboto"
      rel="stylesheet"
      type="text/css"
    />
    <script src="highlightjs/highlight.min.js"></script>
    <script
      type="module"
      crossorigin="anonymous"
      src="https://cdn.jsdelivr.net/npm/@peakman/dagger.js@0.9.17/dagger.js"
      defer
    ></script>
    <!-- dagger.js script -->
    <script type="dagger/configs">
      {
        "demo_container": {
          "uri": "./namespace/demo_module_namespace.html",
          "style": "./styles/card.css"
        },
        "style": { "uri": "./styles/card.css", "scoped": false},
        "_": "./js/loading.js"
      }
    </script>
    <!-- dagger configs -->
    <title>tutorial demo page</title>
  </head>
  <body dg-cloak>
    <div class="section">
      <div class="chapter-title">Welcome to dagger.js</div>
      <span
        >dagger.js is a directive based web framework that is natively supported
        by the browser. This means that there are no apis and no compiling,
        which makes for a clean and intuitive way to design the modern web.
        Every dagger functionality is accessible through the dagger defined
        attributes and configuration. Let's see exactly how it work and how to
        use it with a few simple tutorials. Our tutorials will first introduce
        how a few specific directives work, then work our way to the bigger
        picture where we create reusable components and put it all together into
        a functional web.
      </span>
      <div class="section-title">State management</div>
      <span>
        Having interactive features on a single webpage is the defining
        characteristics of the modern web. Html elements must react to
        constantly changing data or complex user interactions. Behind it all is
        a state management system that keeps track of all the moving pieces.
        Dagger makes it easy through lifecycle directives. Let's see what that
        looks like in action by creating a task card.</span
      >
    </div>
    <!-- <div class="grid-container" +loading="loadingScene1()">
      <div class="code-container">
        <span class="sandbox-label">html</span>
        <div class="code-box">
          <pre><code class="html" $html="demoCode"></code></pre>
        </div>
      </div>
      <div class="render-container">
        <span class="sandbox-label">browser</span>
        <div class="render-box">
          <div class="row">
            <div class="column">
              <span class="dot" style="background: #ed594a"></span>
              <span class="dot" style="background: #fdd800"></span>
              <span class="dot" style="background: #5ac05a"></span>
            </div>
          </div>
          <div class="content" $html="demoRender"></div>
        </div>
      </div>
    </div> -->
    <demo_container +loading="loadingScene1Demo()">
      <div class="grid-container">
        <demo_html></demo_html>
        <demo_browser></demo_browser>
      </div>
    </demo_container>
    <div class="section">
      <span @raw>
        The +loading directive created 3 scope variables: title, assignee, and
        details. The element tags act as natural scopes for the variables, which
        can be readily access and manipulated anywere within the scope with the
        ${} markup. the onloading directive accepts any object, or functions
        that resolve into an object. play around with scope variable values to
        see how it affects the output.
      </span>
      <div class="section-title">Manipulating the scope variables</div>
      <span>
        We can manipulate the scope variable from the browser to add more
        interativity to the task card. First let's create a scope variable
        called is complete, and a button that switches the completed status of
        the card. To add some flare, let's show an orange border for incomplete
        tasks and a green border for completed tasks.
      </span>
    </div>
    <!-- <demo_container +loading="loadingScene2Demo()">
      <div class="grid-container">
        <demo_browser></demo_browser>
        <demo_browser></demo_browser>
      </div>
    </demo_container> -->
    <div
      class="card"
      $class="{complete, collapsed}"
      +loading="{
      title: 'task card', 
   assignee: 'me',
    details: 'play around with the scope variables',
    complete: false,
    collapsed: false,
    complete_btn_click: 'complete=!complete',
    collapse_btn_click: 'collapsed = !collapsed'
}"
    >
      <div class="title" +click="eval(collapse_btn_click)">
        <span>${title}</span>
        <svg
          class="collapse-btn"
          viewBox="0 0 24 24"
          fill="#0078f1"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M5.16108 14.9083C4.45387 15.7165 5.02785 16.9814 6.1018 16.9814H17.898C18.972 16.9814 19.5459 15.7165 18.8388 14.9083L13.3169 8.59762C12.6197 7.80079 11.3801 7.80079 10.6829 8.59762L5.16108 14.9083ZM6.65274 15.4814L11.8118 9.58537C11.9114 9.47154 12.0885 9.47154 12.1881 9.58537L17.3471 15.4814H6.65274Z"
          />
        </svg>
      </div>
      <div class="content">
        <div class="assignee">assigned to: ${assignee}</div>
        <div class="details">${details}</div>
        <button
          class="complete-button"
          +click="eval(complete_btn_click)"
        >
          ${complete?'completed':'not complete'}
        </button>
      </div>
    </div>
  </body>
</html>
